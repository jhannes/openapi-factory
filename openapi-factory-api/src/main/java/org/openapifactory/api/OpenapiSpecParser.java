package org.openapifactory.api;

import lombok.SneakyThrows;
import org.openapifactory.api.codegen.CodegenContact;
import org.openapifactory.api.codegen.CodegenOperation;
import org.openapifactory.api.codegen.CodegenParameter;
import org.openapifactory.api.codegen.CodegenProp;
import org.openapifactory.api.codegen.CodegenObjectSchema;
import org.openapifactory.api.codegen.CodegenSecurityScheme;
import org.openapifactory.api.codegen.CodegenXml;
import org.openapifactory.api.codegen.OpenapiSpec;
import org.openapifactory.api.codegen.types.CodegenAnonymousObjectModel;
import org.openapifactory.api.codegen.types.CodegenArraySchema;
import org.openapifactory.api.codegen.types.CodegenConstantSchema;
import org.openapifactory.api.codegen.types.CodegenEmbeddedEnumSchema;
import org.openapifactory.api.codegen.types.CodegenModel;
import org.openapifactory.api.codegen.types.CodegenOneOfModel;
import org.openapifactory.api.codegen.types.CodegenPrimitiveSchema;
import org.openapifactory.api.codegen.types.CodegenRecordSchema;
import org.openapifactory.api.codegen.types.CodegenSchema;
import org.openapifactory.api.codegen.types.CodegenSchemaRef;
import org.openapifactory.api.parser.Maybe;
import org.openapifactory.api.parser.SpecMappingNode;
import org.openapifactory.api.parser.SpecSequenceNode;

import java.io.IOException;
import java.net.URL;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;

public class OpenapiSpecParser {

    public static final String DEFAULT_SPEC_DESCRIPTION = "No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)";

    public OpenapiSpec createOpenApiSpec(Path apiDocument) throws IOException {
        return createOpenApiSpec(apiDocument.toUri().toURL());
    }

    public OpenapiSpec createOpenApiSpec(URL url) throws IOException {
        return createSpec(url, readSpec(url));
    }

    protected OpenapiSpec createSpec(URL baseUrl, SpecMappingNode node) throws IOException {
        var spec = new OpenapiSpec();
        readSpec(node, spec);
        resolveExternalReferences(baseUrl, spec);
        return spec;
    }

    protected void readSpec(SpecMappingNode node, OpenapiSpec spec) {
        readInfo(node.mappingNode("info").required(), spec);
        readModels(node, spec);
        readServers(node.sequenceNode("servers"), spec);
        readPaths(node.mappingNode("paths").required(), spec);
        readSecuritySchemes(node, spec);
    }

    protected void readServers(Maybe<SpecSequenceNode> servers, OpenapiSpec spec) {
        if (servers.isPresent()) {
            for (var server : servers.required().mappingNodes()) {
                var codegenServer = spec.addServer();
                codegenServer.setDescription(server.string("description").orNull());
                codegenServer.setUrl(server.string("url").orNull());
            }
        } else {
            spec.addServer();
        }
    }

    private void readModels(SpecMappingNode node, OpenapiSpec spec) {
        var components = node.mappingNode("components");
        if (components.isPresent()) {
            var maybeSchemas = components.required().mappingNode("schemas");
            if (maybeSchemas.isPresent()) {
                var schemas = maybeSchemas.required();
                for (var modelName : schemas.keySet()) {
                    var modelNode = schemas.mappingNode(modelName).required();
                    createModel(spec, modelName, modelNode);
                    modelNode.checkUnused();
                }
            }
        }
    }

    protected CodegenModel createModel(OpenapiSpec spec, String modelName, SpecMappingNode node) {
        var type = node.string("type");
        node.mappingNode("externalDocs");
        if (node.containsKey("properties")) {
            var generic = spec.addGenericModel(modelName);
            node.string("description").ifPresent(generic::setDescription);
            node.mappingNode("xml").map(this::readXml).ifPresent(generic::setXml);
            readProperties(node, generic);
            return generic;
        } else if (node.containsKey("enum")) {
            var enumModel = spec.addEnumModel(modelName);
            enumModel.getValues().addAll(node.sequenceNode("enum").required().stringList());
            enumModel.setType(type.orElse("string"));
            node.string("description").ifPresent(enumModel::setDescription);
            return enumModel;
        } else if (node.containsKey("allOf")) {
            var allOf = spec.addAllOfModel(modelName);
            allOf.getRequired().addAll(node.sequenceNode("required")
                    .map(SpecSequenceNode::stringList)
                    .orElse(List.of()));
            for (var superModel : node.sequenceNode("allOf").required().mappingNodes()) {
                if (superModel.containsKey("$ref")) {
                    allOf.addRefSuperModel(superModel.string("$ref").required(), superModel.getRelativeFilename());
                } else if (superModel.containsKey("properties")) {
                    readProperties(superModel, allOf.addSuperModel());
                }
            }
            return allOf;
        } else if (node.containsKey("oneOf")) {
            return readOneOf(node, spec.addOneOfModel(modelName));
        } else if (type.filter(s -> s.equals("array"), "").isPresent()) {
            var array = spec.addArrayModel(modelName);
            readArrayType(spec, node, array, null);
            node.string("description").ifPresent(array::setDescription);
            return array;
        } else {
            throw new IllegalArgumentException("Unsupported model " + modelName + ": " + node);
        }
    }

    private static CodegenOneOfModel readOneOf(SpecMappingNode node, CodegenOneOfModel oneOf) {
        for (var oneOfNode : node.sequenceNode("oneOf").required().mappingNodes()) {
            oneOf.addOneOf(oneOfNode.string("$ref").required(), oneOfNode.getRelativeFilename());
        }
        if (node.containsKey("discriminator")) {
            var discriminatorNode = node.mappingNode("discriminator").required();
            oneOf.getDiscriminator().setPropertyName(discriminatorNode.string("propertyName").orNull());
            if (discriminatorNode.containsKey("mapping")) {
                var mapping = discriminatorNode.mappingNode("mapping").required();
                for (var mappingKey : mapping.keySet()) {
                    var mappingValue = mapping.string(mappingKey).required();
                    if (CodegenSchemaRef.REF_PATTERN.matcher(mappingValue).matches()) {
                        oneOf.addMapping(mappingKey, new CodegenSchemaRef(oneOf.getSpec(), mappingValue, mapping.getRelativeFilename()));
                    } else {
                        oneOf.addMapping(mappingKey, new CodegenSchemaRef(oneOf.getSpec(), "#/components/schemas/" + mappingValue, mapping.getRelativeFilename()));
                    }
                }
            }
        }
        return oneOf;
    }

    protected void readProperties(SpecMappingNode node, CodegenObjectSchema model) {
        var required = node.sequenceNode("required")
                .map(SpecSequenceNode::stringList)
                .orElse(List.of());
        if (node.containsKey("additionalProperties")) {
            if (!node.isObject("additionalProperties")) {
                model.setAdditionalPropertiesFlag(node.getBoolean("additionalProperties").required());
            }
        }
        var properties = node.mappingNode("properties").required();
        for (var name : properties.keySet()) {
            var propNode = properties.mappingNode(name).required();
            createProperty(model, name, required, propNode);
            propNode.checkUnused();
        }
    }

    private void createProperty(CodegenObjectSchema model, String name, List<String> required, SpecMappingNode propNode) {
        var prop = model.addProperty(name);
        if (required.contains(name)) {
            prop.setRequired(true);
        }
        propNode.string("description").ifPresent(prop::setDescription);
        propNode.string("example").ifPresent(prop::setExample);
        prop.setSchema(getSchema(prop.getSpec(), propNode, prop));
        propNode.getBoolean("readOnly").ifPresent(prop::setReadOnly);
        propNode.getBoolean("writeOnly").ifPresent(prop::setWriteOnly);
        propNode.getBoolean("nullable").ifPresent(prop::setNullable);
        propNode.getInt("maxLength").ifPresent(prop::setMaxLength);
        propNode.mappingNode("xml").map(this::readXml).ifPresent(prop::setXml);
    }

    protected void readPaths(SpecMappingNode paths, OpenapiSpec spec) {
        for (var pathExpression : paths.keySet()) {
            var pathNode = paths.mappingNode(pathExpression).required();
            var specialValues = Set.of("$ref", "summary", "description", "servers", "parameters");

            var commonParameters = new ArrayList<CodegenParameter>();
            var parameters = pathNode.sequenceNode("parameters");
            if (parameters.isPresent()) {
                for (var paramNode : parameters.required().mappingNodes()) {
                    var parameter = new CodegenParameter(spec, paramNode.string("name").required());
                    readParameter(paramNode, parameter);
                    commonParameters.add(parameter);
                }
            }

            for (var method : pathNode.keySet()) {
                if (specialValues.contains(method)) {
                    continue;
                }
                var operationNode = pathNode.mappingNode(method).required();
                var tags = operationNode.sequenceNode("tags")
                        .map(SpecSequenceNode::stringList)
                        .orElse(List.of("Default"));

                var operation = spec.createOperation(method, pathExpression);
                operationNode.string("description").ifPresent(operation::setDescription);
                operation.getParameters().addAll(commonParameters);
                readCodegenOperation(operationNode, operation);
                for (var tag : tags) {
                    spec.addOperation(tag, operation);
                }
                operationNode.checkUnused();
            }
            pathNode.checkUnused();
        }
    }

    private void readCodegenOperation(SpecMappingNode operationNode, CodegenOperation operation) {
        operationNode.string("operationId").ifPresent(operation::setOperationId);
        operationNode.string("summary").ifPresent(operation::setSummary);
        operationNode.getBoolean("deprecated").ifPresent(operation::setDeprecated);
        var parameters = operationNode.sequenceNode("parameters");
        if (parameters.isPresent()) {
            for (var parameter : parameters.required().mappingNodes()) {
                var codegenParameter = operation.addParameter(parameter.string("name").required());
                readParameter(parameter, codegenParameter);
            }
        }

        if (operationNode.containsKey("requestBody")) {
            var requestBody = operationNode.mappingNode("requestBody").required();
            var description = requestBody.string("description");
            var content = requestBody.mappingNode("content").required();
            for (var contentType : content.keySet()) {
                var codegenContent = operation.addRequestBody(contentType);
                codegenContent.setRequired(requestBody.getBoolean("required").orElse(false));
                var schema = (content.mappingNode(contentType).required()).mappingNode("schema").required();
                var requestType = getSchema(operation.getSpec(), schema, null);
                if (!codegenContent.isFormContent() && requestType instanceof CodegenAnonymousObjectModel object) {
                    codegenContent.setSchema(operation.addRequestModel(object));
                } else {
                    codegenContent.setSchema(requestType);
                }
            }
            requestBody.checkUnused();
        }
        if (operationNode.containsKey("responses")) {
            var responses = operationNode.mappingNode("responses").required();
            for (var o : responses.keySet()) {
                var maybeContent = responses.mappingNode(o).required().mappingNode("content");
                var response = operation.addResponse(o.equals("default") ? 200 : Integer.parseInt(o));
                if (maybeContent.isPresent()) {
                    var content = maybeContent.required();
                    for (var contentType : content.keySet()) {
                        var codegenContent = response.addResponseType(contentType);
                        var schema = content.mappingNode(contentType).required().mappingNode("schema").required();
                        var responseSchema = getSchema(operation.getSpec(), schema, null);
                        if (responseSchema instanceof CodegenAnonymousObjectModel object) {
                            codegenContent.setSchema(operation.addResponseModel(object, Integer.parseInt(o)));
                        } else {
                            codegenContent.setSchema(responseSchema);
                        }
                        schema.checkUnused();
                    }
                }
            }
        }
        if (operationNode.containsKey("security")) {
            for (var securityNode : operationNode.sequenceNode("security").required().mappingNodes()) {
                for (var key : securityNode.keySet()) {
                    var security = operation.addSecurity(key);
                    securityNode.sequenceNode("key").map(SpecSequenceNode::stringList)
                            .ifPresent(security::setScopes);
                }
            }
        }
    }

    protected void readParameter(SpecMappingNode parameterNode, CodegenParameter parameter) {
        parameter.setRequired(parameterNode.getBoolean("required").orElse(false));
        parameter.setIn(parameterNode.getEnum("in", CodegenParameter.ParameterLocation.class).required());
        parameter.setExplode(parameterNode.getBoolean("explode").orElse(true));
        parameter.setStyle(parameterNode.getEnum("style", CodegenParameter.Style.class).orNull());
        parameter.setSchema(getSchema(parameter.getSpec(), parameterNode.mappingNode("schema").required(), parameter));
    }

    private void readSecuritySchemes(SpecMappingNode node, OpenapiSpec spec) {
        if (node.containsKey("components")) {
            var componentsNode = node.mappingNode("components").required();
            if (componentsNode.containsKey("securitySchemes")) {
                var securitySchemesNode = componentsNode.mappingNode("securitySchemes").required();
                for (var scheme : securitySchemesNode.keySet()) {
                    var schemeNode = securitySchemesNode.mappingNode(scheme).required();
                    var securityScheme = spec.addSecurityScheme(scheme);
                    securityScheme.setType(schemeNode.string("type").required());
                    schemeNode.string("name").ifPresent(securityScheme::setName);
                    schemeNode.getEnum("in", CodegenSecurityScheme.Location.class).ifPresent(securityScheme::setIn);
                    schemeNode.mappingNode("flows"); // TODO: Used for oauth2 security schemes
                    schemeNode.checkUnused();
                }
            }
        }
    }

    protected CodegenSchema getSchema(OpenapiSpec spec, SpecMappingNode schema, CodegenProp prop) {
        if (schema.containsKey("$ref")) {
            return new CodegenSchemaRef(spec, schema.string("$ref").required(), schema.getRelativeFilename());
        }
        var maybeType = schema.string("type");
        if (schema.containsKey("enum")) {
            var values = schema.sequenceNode("enum").required().stringList();
            if (values.size() == 1) {
                return new CodegenConstantSchema(values.get(0));
            }
            var result = new CodegenEmbeddedEnumSchema();
            result.setType(maybeType.orElse("string"));
            result.getValues().addAll(values);
            result.setDeclaredProperty(prop);
            schema.string("description").ifPresent(result::setDescription);
            return result;
        } else if (schema.containsKey("oneOf")) {
            return readOneOf(schema, new CodegenOneOfModel(spec, null));
        } else if (schema.containsKey("properties")) {
            var result = new CodegenAnonymousObjectModel(spec);
            readProperties(schema, result);
            return result;
        } else if (schema.containsKey("additionalProperties")) {
            var result = new CodegenRecordSchema();
            result.setAdditionalProperties(getSchema(spec, schema.mappingNode("additionalProperties").required(), prop));
            return result;
        } else {
            var type = maybeType.required();
            if ("array".equals(type)) {
                var result = new CodegenArraySchema();
                readArrayType(spec, schema, result, prop);
                return result;
            } else {
                var result = new CodegenPrimitiveSchema();
                result.setType(type);
                result.setFormat(schema.string("format").orNull());
                return result;
            }
        }
    }

    protected void readArrayType(OpenapiSpec spec, SpecMappingNode schema, CodegenArraySchema result, CodegenProp prop) {
        result.setUniqueItems(schema.getBoolean("uniqueItems").orElse(false));
        result.setItems(getSchema(spec, schema.mappingNode("items").required(), prop));
        schema.getInt("minItems").ifPresent(result::setMinItems);
        schema.getInt("maxItems").ifPresent(result::setMaxItems);
    }

    protected void readInfo(SpecMappingNode infoNode, OpenapiSpec spec) {
        infoNode.string("title").ifPresent(spec::setTitle);
        spec.setDescription(infoNode.string("description").orElse(DEFAULT_SPEC_DESCRIPTION));
        infoNode.string("version").ifPresent(spec::setVersion);
        infoNode.mappingNode("license");
        infoNode.mappingNode("contact").ifPresent(contactNode -> {
                    var contact = new CodegenContact();
                    contact.setName(Objects.toString(contactNode.string("name").orNull()));
                    contact.setEmail(Objects.toString(contactNode.string("email").orNull()));
                    spec.setContact(Optional.of(contact));
                    contactNode.checkUnused();
                }
        );
        infoNode.checkUnused();
    }

    protected void resolveExternalReferences(URL baseUrl, OpenapiSpec spec) {
        var specFiles = new HashMap<String, SpecMappingNode>();
        Set<CodegenSchemaRef> unresolvedReferences;
        while (!(unresolvedReferences = spec.getUnresolvedSchemaReferences()).isEmpty()) {
            for (var typeReference : unresolvedReferences) {
                var matcher = OpenapiSpec.EXTERNAL_REF.matcher(typeReference.getRef());
                if (matcher.matches()) {
                    var specNode = specFiles.computeIfAbsent(
                            matcher.group("filename"),
                            filename -> readSpec(baseUrl, filename)
                    );
                    var path = matcher.group("anchor").split("/");
                    for (var segment : path) {
                        if (!segment.isEmpty()) {
                            specNode = specNode.mappingNode(segment).required();
                        }
                    }
                    var resolvedModel = createModel(spec, path[path.length - 1], specNode);
                    spec.getResolvedSchemas().put(typeReference, resolvedModel);
                }
            }
        }
    }

    private CodegenXml readXml(SpecMappingNode xmlNode) {
        var result = new CodegenXml();
        xmlNode.string("name").ifPresent(result::setName);
        xmlNode.string("namespace").ifPresent(result::setNamespace);
        xmlNode.string("prefix").ifPresent(result::setPrefix);
        xmlNode.getBoolean("attribute").ifPresent(result::setAttribute);
        xmlNode.getBoolean("wrapped").ifPresent(result::setWrapped);
        xmlNode.checkUnused();
        return result;
    }

    @SneakyThrows
    private static SpecMappingNode readSpec(URL url) {
        return SpecMappingNode.read(url, "");
    }

    @SneakyThrows
    private static SpecMappingNode readSpec(URL baseUrl, String filename) {
        return SpecMappingNode.read(new URL(baseUrl, filename), filename);
    }
}
